<!DOCTYPE html>
<html>
  <head>
    <title>Kitty Litter - Modern Vanilla JS for cookie parsing</title>
    <link rel="icon" href="/favicon.png" size="32x32" type="image/png">
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header>Modern Vanilla JS for cookie parsing</header>
    <nav>
        <ul>
  <li><a href="/blog/index.html">Blog</a></li>
  <li><a href="/index.html">Welcome</a></li>
</ul>

    </nav>
    <main><p>In a <a href="/blog/2015/aug/28/vanilla-js-meets-djangos-csrf/">previous post</a> I wrote a Vanilla JS function for parsing all the current cookies. Since then a couple of things have happened:</p>

<ol>
<li>I realised it was not safe</li>
<li>JS in browsers got better [and I got better at it]</li>
</ol>

<p>It was not safe in as much as it parsed the cookie value once and retained the value. If you were, for instance,  using a SPA, Django might update the CSRF token at any point, making your value stale.  So instead, I've updated the function to get just one value, and perform parsing on each call.</p>

<pre><code>function getCookie (name) {
  let value;

  (document.cookie || '')
    .split(';')
    .map(c =&gt; c.trim().match(/(\w+)=(.*)/))
    .forEach(([m, k, v]) =&gt; {
      if (m !== undefined &amp;&amp; decodeURIComponent(k) === name) {
        value = decodeURIComponent(v);
      }
    });
  return value;
}
</code></pre>

<p>So the process is much the same. We declare a value which defaults to undefined. This way, if we don't find a matching cookie, our value falls out the bottom as undefined.</p>

<p>Then we get the document's cookie attribute, or fall back to an empty string.</p>

<p>Next, we split on ';', and for each resulting string we trim whitespace, and apply our regex.</p>

<p>This results in an Array of (match, key, value) values. We iterate over them, using the JS "spread" feature to unpack the values into separate variables, and test if (a) the Match succeeded ('m' is not undefined), and (b) the key matches the name we've been asked to find.</p>

<p>If it matches, we assign the value to our 'value' variable.</p>

<h2>Addendum (2019-01-21)</h2>

<p>If absolute performance is your schtick... try this:</p>

<pre><code>function getCookie (name) {
  for(let c of (document.cookie || '').split(';')) {
    let [m, k, v] = c.trim().match(/(\w+)=(.*)/)
    if (m !== undefined &amp;&amp; decodeURIComponent(k) === name) {
      return decodeURIComponent(v);
    }
  }
  return undefined;
}
</code></pre>

<p>The main difference is using a <code>for</code> loop, allowing early exit.</p>
</main>
    <footer> Copyright &copy; 2019 Curtis Maloney </footer>
  </body>
</html>
