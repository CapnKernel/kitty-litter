<!DOCTYPE html>
<html>
  <head>
    <title>Wrapping views with decorators</title>
    <link rel="icon" href="/favicon.png" size="32x32" type="image/png">
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header>Wrapping views with decorators</header>
    <nav>
        <ul>

  <li><a href="/blog/index.html">Blog</a></li>

  <li><a href="/index.html">Welcome</a></li>

</ul>

    </nav>
    <main><p>Django provides many decorators for use throughout your project.  They can be great time savers, and mastering them can help you DRY your code considerable.  However, they often confuse people as to how they work, or how to write their own.</p>

<p>In this post I plan to walk through an example of building up a simple decorator that tests if the user has a specific permission, and if not returning a 403 Forbidden response.</p>

<h1>Decorator basics.</h1>

<p>The decorator syntax does <em>not</em> add anything you can't already do in other ways.</p>

<pre><code>def myview(...):
    ...

myview = mydecorator(myview)
</code></pre>

<p>is equivalent to:</p>

<pre><code>@mydecorator
def myview(...):
    ...
</code></pre>

<p>That's right - a decorator just calls your decorator function, passing your function [or class] as its only argument, and assigning the result to the same name.</p>

<h1>Common Code</h1>

<p>So, in this scenario you would find yourself starting a lot of views like this:</p>

<pre><code>def myview(request, ...):
    if not request.user.has_perm('foo.bar'):
        return http.HttpResponseForbidden()
    ...
</code></pre>

<p>Repeating this code is obviously tedious and hazardous.  Tedious because you're repeating yourself, and hazardous because you may update the permission name in one place, but not others.</p>

<h1>Step 1: Fixed permission</h1>

<p>First, we'll write a decorator that will do our permission test, but with a hard-coded permission.</p>

<pre><code>def require_permission(view):

    def _inner(request, *args, **kwargs):
        if not request.user.has_perm('foo.bar'):
            return http.HttpResponseForbidden()
        return view(request, *args, **kwargs)

    return _inner
</code></pre>

<p>So what just happened there?  We defined a new function which implements the permission check, and calls our view if it's ok, returning its result.  Any JavaScript developers will easily recognise this pattern.</p>

<p>The fact it can access the 'view' argument that was never passed to it is a factor of Python scoping.</p>

<p>We can use it as simply as:</p>

<pre><code>@require_permission
def myview(request, ....):
    ...
</code></pre>

<p>Which is equivalent, as mentioned, to:</p>

<pre><code>def myview(request, ...):
    ...

myview = require_permission(myview)
</code></pre>

<p>So, what's returned from require_permission [and assigned to myview] is the wrapper function defined in the decorator.</p>

<h1>Step 2: Variable permission</h1>

<p>But now we want to choose which permission to test for.  Your first thought may be to just pass another argument with the view, but that doesn't work with decorators - it's Python invoking the call, and it only passes one argument: the function.</p>

<p>So what we need is a way to produce new decorator functions, differing on which permission they test.  We need a decorator factory.</p>

<pre><code>def require_permission(perm):

    def _outer(view):
        def _inner(request, *args, **kwargs):
            if not request.user.has_perm(perm):
                return http.HttpResponseForbidden()
            return view(request, *args, **kwargs)
        return _inner

    return _outer
</code></pre>

<p>Holy Inception, Batman!</p>

<p>So, now we have a function which returns a function, which returns a function, which calls our view!</p>

<p>So what happens here is:</p>

<ol>
<li>require_permission('foo.bar') calls our factory function, which returns _outer [the actual decorator]</li>
<li>Python calls our decorator [_outer], passing the view as its argument</li>
<li>Our _outer function then defines a new view function which implements our permission check.</li>
</ol>

<h1>Step 3: Tidying up</h1>

<p>There is one final step to be made.  It's not obvious, but currently if, for whatever reason, the decorator raises an exception, you won't know which decorated function raised the exception.  Fortunately, Python has a solution in functools: wraps.</p>

<pre><code>from functools import wraps

def require_permission(perm):

    def _outer(view):

        @wraps(view)
        def _inner(request, *args, **kwargs):
            if not request.user.has_perm(perm):
                return http.HttpResponseForbidden()
            return view(request, *args, **kwargs)
        return _inner

    return _outer
</code></pre>

<p>The "@wraps" decorator copies the <strong>name</strong>, <strong>module</strong>, and <strong>doc</strong> properties from the wrapped target, onto the function being decorated.  For more details, see <a href="https://docs.python.org/2/library/functools.html#functools.wraps">functools.wraps</a></p>

<h1>Finally</h1>

<p>Of course, there's no reason you can only call decorators using @, since they're just functions.  And so is our decorator factory.  So, coming back to the idea of DRYing out code, we can pre-generate decorators for specific permissions:</p>

<pre><code>require_foo_permission = require_permission('myapp.foo')
require_bar_permission = require_permission('myapp.bar')

@require_foo_permission
def myview(request, ...):
</code></pre>

<p>So now we've removed repetition of the same 'how to test for a permission' code, as well as avoided repeating the name of specific permissions.</p>

<h1>Further reading</h1>

<p>The incomparable Graham Dumpleton has written an extensive series of posts on doing decorators properly, so I highly recommend <a href="http://blog.dscpl.com.au/2014/01/how-you-implemented-your-python.html">reading them</a> yourself.</p>
</main>
    <footer> Copyright &copy; 2019 Curtis Maloney </footer>
  </body>
</html>
