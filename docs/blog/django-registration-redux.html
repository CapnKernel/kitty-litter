<!DOCTYPE html>
<html>
  <head>
    <title>Kitty Litter - Django Registration redux</title>
    <link rel="icon" href="/favicon.png" size="32x32" type="image/png">
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header>Django Registration redux</header>
    <nav>
        <ul>
  <li><a href="/blog/index.html">Blog</a></li>
  <li><a href="/index.html">Welcome</a></li>
</ul>

    </nav>
    <main><p>So, 4 years ago [already??] I wrote a post about a shortcut to getting "User
registration with verification email", using very little code by leveraging the
password reset machinery built into Django.</p>

<p>Since then, of course, Django has moved on... and recently, the auth views were
rewritten as class-based views, which changes the game entirely.</p>

<p>As a result, I've committed to providing here an updated version of the
previous post.</p>

<p>A lot of the following is copied verbatim from the previous article, but I will
update the docs links (from Django 1.7 to 2.1) and clarify where it's been
found valuable.</p>

<p>It's important to note that you should do all of this right at the very <em>start</em> of your project, as advised <a href="https://docs.djangoproject.com/en/2.1/topics/auth/customizing/#using-a-custom-user-model-when-starting-a-project">here</a></p>

<h2>Step 1: User model</h2>

<p>This step has not changed much. We follow the steps
<a href="https://docs.djangoproject.com/en/2.1/topics/auth/customizing/#substituting-a-custom-user-model">here</a>
.</p>

<p>We'll start an app called 'accounts' by running <code>manage.py startapp accounts</code></p>

<p>Then we'll create a User model in there, which inherits from <code>AbstractBaseUser</code>
and <code>PermissionsMixin</code>.</p>

<pre><code>from django.db import models
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin

class User(AbstractBaseUser, PermissionsMixin):
    USERNAME_FIELD = 'email'

    email = models.EmailField(unique=True)
    is_active = models.BooleanField(default=False)
    is_staff = models.BooleanField(default=False)

    # Admin expects these two methods.
    def get_full_name(self):
        return self.email

    def get_short_name(self):
        return self.email
</code></pre>

<p>Add to this whatever other fields you record against all your users - name,
avatar image, what have you.</p>

<p>Why <code>AbstractBaseUser</code>, and not <code>AbstractUser</code>?  Because <code>AbstractUser</code> implements the
default Django user model, and we don't want that.  Notably, it includes
'username' as unique, and 'email' as not.</p>

<p><code>PermissionsMixin</code> gives us <code>is_superuser</code>, <code>groups</code> and <code>user_permissions</code>, as
well as the right methods to participate in the normal permissions machinery.</p>

<p>Now we also need to add a custom Manager to help the rest of Django.</p>

<pre><code>from django.contrib.auth.models import BaseUserManager


class UserManager(BaseUserManager):

    def _create_user(self, email, password, **kwargs):
        user = self.model(
            email=self.normalize_email(email),
            is_active=True,
            **kwargs
        )
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, email, password, **kwargs):
        kwargs.setdefault('is_staff', False)
        kwargs.setdefault('is_superuser', False)
        return self._create_user(email, password, **kwargs)

    def create_superuser(self, email, password, **kwargs):
        kwargs.setdefault('is_superuser', True)
        kwargs.setdefault('is_staff', True)
        return self._create_user(email, password, **kwargs)
</code></pre>

<p>You may be wondering what "normalize_email" does?  That lower-cases the host
name of the email address (everything right of the @) to avoid case clashes.
Many people wonder why not also lower case the mailbox name (everything left of
the @)? According to the RFCs, that's an invalid transform - you can assume
host names are lower case-able, but not mailboxes.</p>

<p>Next we tell our User model to use this by adding:</p>

<pre><code>objects = UserManager()
</code></pre>

<p>to your User model.</p>

<p>Finally, set <code>AUTH_USER_MODEL</code> in your <code>settings.py</code></p>

<pre><code>AUTH_USER_MODEL = "accounts.User"
</code></pre>

<h2>2. Registration</h2>

<p>This is where the clever part comes.</p>

<p>Instead of creating all our own code to manage sending the email and verifying
the token, we can re-use the <a href="https://docs.djangoproject.com/en/2.1/topics/auth/default/#django.contrib.auth.views.PasswordResetView">existing password reset machinery</a>
that's built into Django!</p>

<p>Let's face it, what's the difference between a verification email for registration, and one for password reset?</p>

<p>We just need to hook in the existing views, and tweak them to use different
templates.</p>

<p>We will need to create a form, so in <code>accounts/forms.py</code> add:</p>

<pre><code>from django import forms

from . import models


class RegistrationForm(forms.ModelForm):
    class Meta:
        model = models.User
        fields = ['email']
</code></pre>

<p>Notice we don't put the password here. Later when the users passes through the <code>PasswordResetConfirmView</code> their new password will be set.</p>

<p>Next we create a sub-class of the default <code>PasswordResetForm</code>. In <code>PasswordResetView</code>, it's actually the form class that contains all the code to send the emails.</p>

<p>This form has a <code>get_user</code> method which will query for Users with matching emails, as well as <code>is_active</code> being True, and will then filter for those having a "usable" password.</p>

<p>We need to change how it finds the list of users to send emails, since we already have the User:</p>

<pre><code>from django.contrib.auth.forms import PasswordResetForm


class RegistrationEmailForm(PasswordResetForm):
    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def get_users(self, email):
        return (self.user,)
</code></pre>

<p>Now, we add our registration view to <code>accounts/views.py</code>:</p>

<pre><code>from django.contrib.auth.views import PasswordResetView
from django.urls import reverse_lazy

from . import forms


class UserRegistrationView(PasswordResetView):
    template_name = 'register/register_form.html'
    form_class = forms.RegistrationForm
    email_template_name = 'register/registration_email.txt'
    # html_email_template_name = Set
    subject_template_name = 'register/registration_subject.txt'
    success_url = reverse_lazy('register-done')

    def form_valid(self, form):
        self.object = form.save(commit=False)
        self.object.set_unusable_password()
        self.object.is_active = True
        self.object.save()

        form = forms.RegistrationEmailForm(self.object, self.request.POST)
        form.is_valid()  # Must trigger validation
        return super().form_valid(form)
</code></pre>

<p>So here we're taking the existing <code>PasswordResetView</code>, and overriding a bunch of
attributes, as well as extending the <code>form_valid</code> method to save our User, then
replace the form with our custom sub-class of <code>PasswordResetForm</code>.</p>

<p>As a precaution, we set an unusable password on the user. This guarantees they can't log in, and must complete the email verification to set as password.</p>

<p>Lastly we, create our <code>accounts/urls.py</code>. Instead of sub-classing all of the other views, we can override their config attributes when calling <code>as_view()</code>:</p>

<pre><code>from django.contrib.auth import views as auth
from django.urls import path, reverse_lazy

from . import views


urlpatterns = [
    path('register/',
        views.UserRegistrationView.as_view(),
        name='register'
    ),
    path('register/done/',
        auth.PasswordResetDoneView.as_view(
            template_name='register/register_done.html',
        ),
        name='register-done',
    ),
    path('register/&lt;uidb64&gt;/&lt;token&gt;/',
        auth.PasswordResetConfirmView.as_view(
            template_name='register/register_confirm.html',
            success_url=reverse_lazy('accounts:register-complete'),
        ),
        name='register-confirm'
    ),
    path('register/complete/',
        auth.PasswordResetCompleteView.as_view(
            template_name='register/register_complete.html'
        ),
        name='register-complete'
    ),

]
</code></pre>

<p>This is a near exact copy of <code>django.contrib.auth.urls</code>, but for three things:</p>

<ol>
<li>We're using our own <code>UserRegistrationView</code> instead of <code>PasswordResetView</code></li>
<li>We've changed the template_names.</li>
<li>We've altered the successurls to point to our own urls.</li>
</ol>

<p>Finally, hook these URLs into your root urls.py</p>

<pre><code>urlpatterns = [
    ...
    path(r'accounts/', include('accounts.urls', namespace='accounts')),
    ...
]
</code></pre>

<h2>Templates</h2>

<p>Remember to write the following templates:</p>

<ul>
<li>register/register.html : Presents the registration form, including the <code>email</code> field.</li>
<li>register/registration_email.txt : Body of the verification email</li>
<li>register/registration_subject.txt : Subject-line of the verification email</li>
</ul>

<p>See <a href="https://docs.djangoproject.com/en/2.1/topics/auth/default/#django.contrib.auth.views.PasswordResetView">here</a> for what context is provided.</p>

<ul>
<li>register/register_done.html : Shown after the initial registration form is submitted, after the email is sent.</li>
</ul>

<p>This should instruct the user to check for the email.</p>

<ul>
<li>register/register_confirm.html : Displayed when the user follows the email verification link.</li>
</ul>

<p>See <a href="https://docs.djangoproject.com/en/2.1/topics/auth/default/#django.contrib.auth.views.PasswordResetConfirmView">here</a> for what context is provided.</p>

<ul>
<li>register/register_complete.html : Final step, once password is updated.</li>
</ul>

<h2>Credit</h2>

<p>Thanks xrogaan for all your feedback!</p>
</main>
    <footer> Copyright &copy; 2019 Curtis Maloney </footer>
  </body>
</html>
